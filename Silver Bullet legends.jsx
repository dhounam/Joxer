// // PROCESS ONE LEGEND// Called from processLegends. Arg is a single legend 'pair' of pathItem (rect or line)// and text (textFrame or group-of-tspans)function processOneLegend(legGroup, counter) {	// Let's get the pathitem out of the way first	var legPath = legGroup.pathItems[0];	setPathAttributes(legPath);	// Now text could be either a group of tspans, or a single textFrame.	// Start with group...	var grpCount = legGroup.groupItems.length;	var legText;	if (grpCount > 0) {		legText = legGroup.groupItems[0];		rationaliseText(legText, true);	} else {		legText = legGroup.textFrames[0];		// NOTE: why doesn't this go through rationaliseText?		setTextFrameAttributes(legText);	}    // Name everything    legGroup.name = c_myLegendPair + counter;    legGroup.textFrames[0].name = c_myLegendText;    legPath.name = c_myLegendKey;	return true;}// PROCESS ONE LEGEND ends// PROCESS LEGEND SET// Called from processLegends to unpick// one legend-setfunction processLegendSet(legSet) {// Each legendSet should consist of:	//	- a header group	//	- 2 or more indexed legend groups--	// 		each containing a key and a text-group...	var legCount = legSet.groupItems.length		// Is this necessary?	// if (legCount < 2) { return false; }	// The legend-set group should contain 2 items:	//		legend header group	//		legend key group	// Looping:	// $.bp();	for (var legNo = 0; legNo < legCount; legNo++) {		var oneGroup = legSet.groupItems[legNo];		if (oneGroup.name.search('key') >= 0) {			// This is the 'key' group, containing 2 or more			// legend-pair groups. I process those:             // For naming             var counter = 1;			for (var i = oneGroup.groupItems.length - 1; i >= 0; i--) {				var lPairGroup = oneGroup.groupItems[i];				processOneLegend(lPairGroup, counter);                 counter++;			}		}		else if (oneGroup.name.search('header')) {			// Header group			if (oneGroup.textFrames.length > 0) {				var theHeader = oneGroup.textFrames[0];				setTextFrameAttributes(theHeader);				alert('Check that legend header is being properly processed')				// NOTE: header doesn't move up --already where we want it...			} else {                oneGroup.remove();             }		}	}	}// PROCESS LEGEND SET endsfunction restructureLegendSet(legSet) {	var legCount = legSet.groupItems.length;	// The legend set should consist of 2 groups:	// keys and header. Loop to isolate the keys	var keysGroup;	for (var legNo = 0; legNo < legCount; legNo++) {		var oneGroup = legSet.groupItems[legNo];		if (oneGroup.name.search('key') >= 0) {			// This is the 'keys' group			keysGroup = oneGroup;		}	}	if (typeof keysGroup !== undefined) {		for (var i = keysGroup.groupItems.length - 1; i >= 0; i--) {			var lPairGroup = keysGroup.groupItems[i];			lPairGroup.move(legSet, ElementPlacement.PLACEATEND);		}	}}// PROCESS LEGENDS// Called from processSibyl. Arg is the main legends group, 'silver-chart-legends-group', which is a child// of the background layer and will contain one or more legendset-groups ('legendset-group-n')function processLegends(myDoc) {	// First, look for a legends group	try {		var itsLegendsGroup = myDoc.groupItems[c_itsLegendsGroup];	}	catch (e) {		// No legend sets found. Fair enough.		return true;	}	// Still here? the imported legends group,	// consists of one or more legendset groups.	// While these exist in a limited context, I'll restructure	// Legends group contains two or more legendset groups,	// each containing:	//		a legend-header group (possibly empty)	//		a legend-key group containing 2 or more legend groups,	//			each containing:	//					a key element	//					a group of textFrames	// First, move all legend-key groups up a level	var setCount = itsLegendsGroup.groupItems.length;	if (setCount === 0) {			return true;	}	// Still here? There's at least 1 legend-set    // Process backwards, but number forwards!    var counter = 1	for (var setNo = setCount - 1; setNo >= 0; setNo--) {		var mySet = itsLegendsGroup.groupItems[setNo];		processLegendSet(mySet);        mySet.name = c_myLegendSet + counter;        counter++;	}	// Now restructure	// NOTE: ideally I'd have done this from processLegendSet,	// but Illustrator bombs	var backLayer = myDoc.layers[c_myBackLayer];	// Legend pairs move up a level, and legend sets move to 	// my background layer	// Loop by legendSets	for (var setNo = setCount - 1; setNo >= 0; setNo--) {		var mySet = itsLegendsGroup.groupItems[setNo];		restructureLegendSet(mySet);	}	// Now that everything's clean, move into the background layer	var setCount = itsLegendsGroup.groupItems.length;	for (var setNo = setCount - 1; setNo >= 0; setNo--) {		var lSet = itsLegendsGroup.groupItems[setNo];		lSet.move(backLayer,ElementPlacement.PLACEATBEGINNING);	}	// Kill the import group	itsLegendsGroup.remove();	return true;}// PROCESS LEGENDS ends